<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Deadline：2023-11-15 23:59:59  Warning：本次实验难度较高，可能需要花费较长时间。 Warning：本次实验难度较高，实验的分数与投入并非成正比，请合理安排时间。 Warning：本次实验难度较高，请理性看待，不必过度追求完美。 Warning：本次实验难度较高，但也不要忘记学术诚信（什么事情能做，什么不能）  看到上述警告，或许你会有一些担忧。但请放心，我们的">
<meta property="og:type" content="article">
<meta property="og:title" content="Coroutine lab">
<meta property="og:url" content="https://cjinfdu.github.io/ics/CoroutineLab/index.html">
<meta property="og:site_name" content="COMP130201.02 计算机系统基础">
<meta property="og:description" content="Deadline：2023-11-15 23:59:59  Warning：本次实验难度较高，可能需要花费较长时间。 Warning：本次实验难度较高，实验的分数与投入并非成正比，请合理安排时间。 Warning：本次实验难度较高，请理性看待，不必过度追求完美。 Warning：本次实验难度较高，但也不要忘记学术诚信（什么事情能做，什么不能）  看到上述警告，或许你会有一些担忧。但请放心，我们的">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-10-26T00:00:00.000Z">
<meta property="article:modified_time" content="2023-10-26T01:57:12.456Z">
<meta property="article:author" content="FDUICS-2023助教组">
<meta name="twitter:card" content="summary">
    
    
        
          
              <link rel="shortcut icon" href="/ics/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/ics/images/android-chrome-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/ics/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>Coroutine lab</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/ics/css/style.css">

    <!-- rss -->
    
    
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/ics/">Home</a></li>
         
          <li><a href="/ics/staff/">Staff</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/cjinfdu/ics">Github</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/ics/datalab-comment/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://cjinfdu.github.io/ics/CoroutineLab/"><i class="fa fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://cjinfdu.github.io/ics/CoroutineLab/&text=Coroutine lab"><i class="fa fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://cjinfdu.github.io/ics/CoroutineLab/&title=Coroutine lab"><i class="fa fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://cjinfdu.github.io/ics/CoroutineLab/&is_video=false&description=Coroutine lab"><i class="fa fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Coroutine lab&body=Check out this article: https://cjinfdu.github.io/ics/CoroutineLab/"><i class="fa fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://cjinfdu.github.io/ics/CoroutineLab/&title=Coroutine lab"><i class="fa fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://cjinfdu.github.io/ics/CoroutineLab/&title=Coroutine lab"><i class="fa fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://cjinfdu.github.io/ics/CoroutineLab/&title=Coroutine lab"><i class="fa fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://cjinfdu.github.io/ics/CoroutineLab/&title=Coroutine lab"><i class="fa fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://cjinfdu.github.io/ics/CoroutineLab/&name=Coroutine lab&description="><i class="fa fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%AE%9E%E9%AA%8C%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、实验简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-number">2.</span> <span class="toc-text">二、实验内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#part-0"><span class="toc-number">2.1.</span> <span class="toc-text">part 0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-1-10%E5%88%86"><span class="toc-number">2.2.</span> <span class="toc-text">part 1 （10分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-2-18%E5%88%86"><span class="toc-number">2.3.</span> <span class="toc-text">part 2 （18分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-2.5-10%E5%88%86"><span class="toc-number">2.4.</span> <span class="toc-text">part 2.5 （10分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-3-10%E5%88%86"><span class="toc-number">2.5.</span> <span class="toc-text">part 3 （10分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-4-10%E5%88%86"><span class="toc-number">2.6.</span> <span class="toc-text">part 4 （10分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-5-20%E5%88%86"><span class="toc-number">2.7.</span> <span class="toc-text">part 5 （20分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">2.8.</span> <span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%8F%90%E4%BA%A4%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.</span> <span class="toc-text">四、提交事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">五、参考资料</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index width mx-auto px2 my4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Coroutine lab
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">COMP130201.02 计算机系统基础</span>
      </span>
      
    <div class="postdate">
        <time datetime="2023-10-26T00:00:00.000Z" itemprop="datePublished">2023-10-26</time>
    </div>


      

    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <blockquote>
<p>Deadline：2023-11-15 23:59:59</p>
</blockquote>
<p><strong>Warning</strong>：本次实验难度较高，可能需要花费较长时间。</p>
<p><strong>Warning</strong>：本次实验难度较高，实验的分数与投入并非成正比，请合理安排时间。</p>
<p><strong>Warning</strong>：本次实验难度较高，请理性看待，不必过度追求完美。</p>
<p><strong>Warning</strong>：本次实验难度较高，但也不要忘记<a target="_blank" rel="noopener" href="https://integrity.mit.edu/">学术诚信（什么事情能做，什么不能）</a></p>
<blockquote>
<p>看到上述警告，或许你会有一些担忧。但请放心，我们的目的并非为难各位同学们，而是希望大家在能够在实践中灵活运用所学知识。</p>
<p>正如前文所提，实验可能不同于您之前经历的，不一定会花费很少时间就能取得满分。然而，人生不如意事十有八九，而生活本身就是一个trade-off的过程。</p>
<p>尽管我们说了很多，您可能仍然感到担忧。但回想一下《小马过河》的故事，难度因人而异，实验可能对您来说只是稍微有些挑战而已。</p>
<p>因此，请做好心理准备，让我们开始吧！</p>
</blockquote>
<h2 id="一实验简介">一、实验简介</h2>
<p>本次实验对应 CSAPP 第三章、第四章的内容。</p>
<p>在本次实验中，我们将逐步迭代开发一个简易的协程库，从使用系统调用实现协程，到使用汇编实现协程，从有栈协程到C++ 20引入的无栈协程。</p>
<blockquote>
<p>这里并不是说无栈协程会比有栈协程更好，而是为了让大家了解协程的实现原理，以及不同实现方式的优缺点。两种实现方式没有优劣之分。</p>
</blockquote>
<p>本次实验开发语言为C++，由于在部分代码中使用到了C++ 20的新特性，因此要求g++版本大于等于11。</p>
<blockquote>
<p>Ubuntu 20.04 LTS自带的g++版本为9.3.0，因此需要手动升级g++版本。</p>
<p>Ubuntu 22.04 LTS自带的g++版本为11.2.0，因此无需手动升级g++版本。</p>
<p>关于Ubuntu上g++版本升级，可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/quxuexi/article/details/121501679">这篇博文</a>。如果怕破坏环境，可以只跟做博文中的前4步。并使用命令<code>g++-11</code>来使用g++ 11。</p>
</blockquote>
<p>本次实验发布包包含如下文件： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">├── libco_v1    </span><br><span class="line">│   ├── Makefile</span><br><span class="line">│   ├── coro.cpp</span><br><span class="line">│   ├── coro.h  </span><br><span class="line">│   └── main.cpp</span><br><span class="line">├── libco_v2</span><br><span class="line">│   ├── coro_ctx.cpp</span><br><span class="line">│   ├── coro_ctx.h</span><br><span class="line">│   ├── coro_ctx_swap.S</span><br><span class="line">│   ├── coroutine.cpp</span><br><span class="line">│   ├── coroutine.h</span><br><span class="line">│   ├── main.cpp</span><br><span class="line">│   └── makefile</span><br><span class="line">├── libco_v3</span><br><span class="line">│   ├── main.cpp</span><br><span class="line">│   └── makefile</span><br><span class="line">├── libco_v4</span><br><span class="line">│   ├── generator.h</span><br><span class="line">│   ├── main.cpp</span><br><span class="line">│   └── makefile</span><br><span class="line">└── libco_v5</span><br><span class="line">    ├── generator.h</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    ├── makefile</span><br><span class="line">    └── sleep.h</span><br></pre></td></tr></table></figure></p>
<p>发布包下载链接：<a href="libco-handout.tar">libco-handout</a></p>
<p>本次实验分为五个部分，每个部分都是一个独立的协程库，每个部分都会有一个<code>main.cpp</code>文件，用于测试协程库的功能。</p>
<blockquote>
<p>可能同学们会觉得5个部分太多了，但实际上每个部分都是在上一个部分的基础上进行迭代开发，在此过程中你可以愉快的ctrl + c &amp; ctrl + v。并且正因如此，实验难度的梯度不会很大。</p>
</blockquote>
<blockquote>
<p>hint：实验中会牵涉到的新概念较多，建议大家好好阅读文档中的提示以及参考资料。</p>
</blockquote>
<h2 id="二实验内容">二、实验内容</h2>
<blockquote>
<p>hint：以下标注了<code>任务？（？分）</code>的问题，需要在提交的实验报告中回答，并计入实验分数。</p>
</blockquote>
<h3 id="part-0">part 0</h3>
<p>作为实验的第一部分，我们将在这里逐步介绍实验中你可能遇到的新概念。</p>
<p>我们首先考虑一个普通的函数调用过程。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = a + b;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">40</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">add</span>(a, b);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">foo</span>();</span><br><span class="line">    std::cout &lt;&lt; ret &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>任务一（5分）</strong> 使用GDB，在提交的实验报告中，分析函数的调用过程，并画出从 <code>main</code> 函数中调用 <code>foo</code> 函数开始，一直到 <code>foo</code> 函数返回 <code>ret</code> 的过程中的栈帧变化。</p>
<blockquote>
<p>hint：分析过程中可以注意以下几点：</p>
<ul>
<li><p><code>rbp</code>、<code>rsp</code>的变化</p>
<ul>
<li>每次压栈的内容是什么</li>
</ul></li>
<li><p>函数参数是如何传递的</p></li>
<li><p>函数的返回值是如何传递的</p></li>
</ul>
<p>重点是画出栈帧上存了什么东西。</p>
</blockquote>
<p>通过课堂上的学习，结合上面的小实验，我们不难发现，在函数的调用到运行再到返回的过程中，栈帧起到了至关重要的作用。它为函数的调用提供了一个运行环境，存储了函数的参数、局部变量、返回值以及返回地址等信息。</p>
<p>如果，我们希望一个函数能够在运行过程中暂停，然后再恢复运行（这就是我们本次实验中将要实现的协程），此时栈并不能满足我们的需求，这是为什么？</p>
<p><strong>任务二（4分）</strong> 阅读<a target="_blank" rel="noopener" href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">Coroutine Theory</a>这篇文章，回答以下问题：</p>
<ol type="1">
<li>一个“普通”的函数支持哪两个操作，分别承担了什么功能？</li>
<li>为什么我们说调用栈不能满足协程的要求？</li>
<li>协程作为一种泛化的函数，支持了哪几个操作，分别承担了什么功能？</li>
<li>如果不能使用栈来实现协程，那么我们可以将函数运行时所需的信息存储在哪里？</li>
</ol>
<blockquote>
<p>都是些很简单的小问题，也<strong>不用回答的过于严肃</strong>，<strong>不要求结果正确</strong>，主要是体现思考的过程。最最主要的是为了让大家好好看这篇文章，虽然这篇文章有点长，但是真的是一篇很好的文章。</p>
</blockquote>
<p>在看了文章后，你可能已经对协程有了一个初步的了解。但在这里，我还想就一些概念进行一些补充。</p>
<p>我们不难发现，想要暂停并恢复一个函数的运行，我们需要保存一些数据，我们称之为上下文（context）。在Wikipedia中，上下文的定义如下：</p>
<blockquote>
<p>任务的上下文（context）是一个任务所必不可少的一组数据。这些数据完全描述了这个任务的执行状态，通过存储这些数据，我们可以将任务暂停并在另一个地方恢复正常执行，也可以在不影响执行的情况下复制任务。</p>
</blockquote>
<p>因此，实现协程的关键在于如何保存和恢复上下文。</p>
<p>回忆第四章讲的内容，程序最终运行在CPU上，而CPU可以视作是一个复杂的状态机，它一条一条的读入汇编指令，改变自己的状态。</p>
<p><strong>任务三（3分）</strong> CPU的状态包括哪些？一个显然的问题是，我们不能一下保存所有的状态，结合函数调用约定，以及任务二中第四个问题的回答，你认为我们需要保存哪些状态用于暂停并恢复一个函数的运行？</p>
<p>结合上面的讨论，我们可以推测协程就是上下文+函数。理论部分的介绍就先到这里，接下来我们将逐步实现一个协程库。</p>
<h3 id="part-1-10分">part 1 （10分）</h3>
<p>本部分对应<code>libco/libco_v1</code>。 在本部分中，我们将暂时不会深入到上下文的具体细节，而是使用Linux提供的<code>ucontext</code>库来实现一个简单的协程。</p>
<blockquote>
<p>实验要求在Linux环境下完成，因为<code>ucontext</code>库只在Linux环境下可用。</p>
</blockquote>
<p>在<code>ucontext</code>库中，为我们提供了一个存储了上下文的结构体<code>ucontext_t</code>，以及一组操作上下文的函数。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getcontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makecontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp, <span class="type">void</span> (*func)(), <span class="type">int</span> argc, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">setcontext</span><span class="params">(<span class="type">const</span> <span class="type">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">swapcontext</span><span class="params">(<span class="type">ucontext_t</span> *oucp, <span class="type">ucontext_t</span> *ucp)</span></span>;  </span><br></pre></td></tr></table></figure></p>
<ol type="1">
<li><p><code>getcontext</code>函数用于获取当前上下文并保存在<code>ucp</code>中。</p></li>
<li><p><code>setcontext</code>函数用于当前的上下文为<code>ucp</code>。<br />
<code>setcontext</code>的上下文<code>ucp</code>应该通过<code>getcontext</code>或者<code>makecontext</code>取得。</p></li>
<li><p><code>swapcontext</code>函数用于保存当前上下文到<code>oucp</code>，并将<code>ucp</code>设置为当前上下文</p></li>
<li><p><code>makecontext</code>函数用于修改<code>ucp</code>。</p></li>
</ol>
<p>需要注意的是，在调用<code>makecontext</code>之前必须调用<code>getcontext</code>初始化该上下文，然后为该上下文分配一个栈空间；当上下文通过<code>setcontext</code>或者<code>swapcontext</code>激活后，就会紧接着调用第二个参数指向的函数<code>func</code>；最后，参数<code>argc</code>代表<code>func</code>所需的参数，在调用<code>makecontext</code>之前可以初始化<code>ucp-&gt;uc_link</code>，表示<code>func()</code>执行之后，将要切换到<code>ucp-&gt;uc_link</code>所代表的上下文，其实是隐式的调用了setcontext函数，如果设置为<code>NULL</code>，那么当<code>func()</code>执行完毕后，程序将会继续中止。</p>
<p>如果看了上面的说明，你还是不太清楚的话，我们也为你准备了一些使用的例子： <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">ucontext_t</span> ctx;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getcontext</span>(&amp;ctx);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, ICS 2023!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">setcontext</span>(&amp;ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 不难发现，上面的代码在运行时会死循环。因为程序通过<code>setcontext</code>重新回到来<code>getcontext</code>记录的地方，然后输出<code>Hello, ICS 2023!</code>，接着再次调用<code>setcontext</code>，如此循环。</p>
<p>更详细的介绍可以参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/ink19/p/ucontext.html">这篇博文</a>。</p>
<p>回到我们的实验，在<code>libco_v1/coro.h</code>中，你需要补全<code>coroutine</code>结构体的实现，为了实现后续的功能，你可能需要在<code>coroutine</code>结构体中添加一些成员变量。</p>
<p>接下来我们介绍<code>coroutine_env</code>的概念，它是一个全局的结构体，用于存储协程的调用信息。类似于普通函数的调用，协程间自然也会存在调用关系，因此，你需要在其内部实现一个栈结构，用于记录协程间的调用关系。</p>
<p>由于我们的实验不涉及多线程环境，因此协程最终是并发执行的，从而我们只需要及时的将协程从栈中压入、弹出即可。当然，在返回时，我们可能需要获取栈中的元素，因此我们也提供了<code>get_coro</code>函数。不必担心没有存储所有的协程会导致资源泄露，协程在<code>main</code>函数中创建时，会返回其指针，因此我们可以通过这个指针来释放协程的资源。</p>
<blockquote>
<p>hint：你可能需要在<code>coroutine_env</code>压入一个主协程<code>main_coro</code>，用于记录<code>main</code>函数的上下文。这可以在<code>coroutine_env</code>的构造函数中完成。</p>
<p>另外，在目前的实验中，不会涉及到协程的递归调用，所以栈的深度可以只设置为<code>2</code>。</p>
<p>另外，多用<code>&lt;cassert&gt;</code>的<code>assert</code>函数，可以帮助你在调试时快速检查和定位错误。</p>
</blockquote>
<blockquote>
<p>这便是<code>libco_v1/coro.h</code>中需要完善的内容。如果有不清楚的地方，及时向助教提问！！！</p>
</blockquote>
<p>完成了<code>libco_v1/coro.h</code>中的内容后，你需要在<code>libco_v1/coro.cpp</code>中实现协程的创建（<code>create</code>）、释放（<code>release</code>）、恢复（<code>resume</code>）、暂停（<code>yield</code>）这四个函数。</p>
<p><code>create</code>函数用于创建一个协程，并返回该协程的指针。 &gt; hint：如果你在<code>coroutine</code>的构造函数中完成了部分资源的初始化，那么在<code>create</code>函数中，你只需要使用<code>new</code>来创建一个<code>coroutine</code>对象即可。 &gt; &gt; 你可能会感到疑惑，为什么这里不需要设置上述提到的<code>coroutine</code>上下文中的相关内容。对此，我们采用<code>lazy</code>的策略，即只有在协程被激活时，才会设置其上下文。</p>
<p><code>release</code>函数用于释放一个协程的资源。</p>
<blockquote>
<p>如果你在<code>create</code>函数中使用了<code>new</code>，那么在<code>release</code>函数中，你需要使用<code>delete</code>来释放协程的资源。</p>
<p>注意：你需要完成<code>coroutine</code>的析构函数，用于释放协程的资源。否则会发生内存泄露。</p>
</blockquote>
<p><code>func_wrap</code>是一个辅助函数，从它的实现可以看出，它同一了协程的进入，并在协程退出时，设置相关标志位。最后使用<code>yield</code>函数回到主协程。在这里，我们约定<code>yield</code>返回<code>-1</code>表示协程的结束。</p>
<p><code>resume</code>函数用于恢复一个协程的运行。其第一个参数是需要恢复的协程；第二个参数是传递给协程的参数，该参数会通过<code>yield</code>函数返回给调用者。</p>
<p><code>yield</code>函数用于暂停一个协程的运行，并返回给调用者。其第一个参数是传递给调用者的返回值，该参数会通过<code>resume</code>函数返回给调用者。</p>
<blockquote>
<p>这里奇怪的点在于，从执行流来看，<code>resume</code>会返回到<code>yield</code>，而<code>yield</code>会返回到<code>resume</code>。因此，在这个过程中，你可能需要通过一些方式保存函数的参数和返回值。</p>
<p>一个自然的想法是在每个<code>coroutine</code>结构体内设置一个<code>data</code>字段，用于双方的通信。</p>
<p><code>resume</code>时将要传入的参数保存在即将恢复的协程的该字段，并通过<code>yield</code>返回自身的<code>data</code>字段。反过来，<code>yield</code>时将要返回的参数保存在主协程的<code>data</code>字段，并通过<code>resume</code>返回的<code>data</code>字段。</p>
<p>hint：从上面的提示可以发现，这中间存在上下文的切换。注意函数的调用时机，以及函数的返回值。</p>
</blockquote>
<p>在实现完上面的代码后，就可以进入到<code>libco/libco_v1</code>文件夹下，使用<code>make</code>命令编译代码，并使用<code>./main</code>命令运行代码了。</p>
<p>如果一切正常，会看到对应的输出。</p>
<blockquote>
<p><code>main</code>函数很简单的，可以自己看看。</p>
</blockquote>
<h3 id="part-2-18分">part 2 （18分）</h3>
<p>本部分对应<code>libco/libco_v2</code>。</p>
<p>在这里，我们将自己使用汇编来实现协程的上下文切换。</p>
<p>首先是我们自定义的<code>coro_ctx</code>结构体，你需要在其中添加需要保存的上下文。</p>
<blockquote>
<p>hint：其中可能包括所有的callee-save寄存器，以及用于传递参数的六个寄存器。</p>
<p>另外，考虑到我们需要伪造函数调用环境，你可能需要保存栈指针和函数地址。此处存函数地址，并在第一次被<code>resume</code>时，设置好所有寄存器的值后，将其压入栈中，那么<code>resume</code>返回时，就会依据调用约定，将<code>rsp</code>指向的地址作为返回地址，从而跳转到函数地址处，实现函数切换。在后续暂停和恢复中，我们都会这样做，使得函数恢复到上次暂停的位置。</p>
<p>因此，保存当前上下文，恢复下一个上下文，这两个操作都需要在汇编中完成。通过调用约定我们知道，函数的第一个参数是<code>rdi</code>，第二个参数是<code>rsi</code>，在此基础上，我们就可以编写对应的汇编操作了。</p>
<p>需要补充的一点是，结构体的内存布局是从低地址到高地址的，保存和恢复上下文时，需要注意上下文中变量的顺序（也就是相对于<code>rdi</code>/<code>rsi</code>的偏移量）。</p>
</blockquote>
<p>通过上面的解释，你可能已经大致了解了什么叫context swap。你需要在<code>coro_ctx_swap.S</code>中实现<code>coro_ctx_swap</code>函数。</p>
<p>然后，你需要在<code>coro_ctx.cpp</code>中实现<code>ctx_make</code>函数，用于初始化<code>coro_ctx</code>结构体。</p>
<blockquote>
<p>在这里，你需要初始化<code>coro_ctx</code>结构体中的成员变量。</p>
</blockquote>
<p>在完成了part 1后，你已经发现了我们需要为协程提供栈，我们的实现方法是从堆上申请一大片空间将其作为栈。在这里，我们已经给出了<code>stack_mem</code>的框架，你需要补全其中的代码并在后续的代码中使用。关于<code>share_stack</code>，我们会在后续介绍到。</p>
<p>对于<code>coroutine</code>结构体，你可以仿照part 1中的实现。</p>
<p>在<code>coroutine_env</code>中，你需要拓展part 1中的实现，使其支持协程的嵌套调用。</p>
<blockquote>
<p>其实只是让调用栈的深度变大了而已。</p>
</blockquote>
<p>接着是<code>coroutine.cpp</code>中的四个函数。语义与part 1中的函数保持一致。</p>
<p>此外，我们定义了辅助函数<code>swap</code>用于切换上下文，在part 1的基础上，你已经大致了解了这个函数中需要做什么，其核心<code>coro_ctx_swap</code>你也已经实现，那么这里并不复杂。</p>
<h3 id="part-2.5-10分">part 2.5 （10分）</h3>
<p>在上面的实现中，你可能会觉得我们对栈的申请有点浪费，因为并不是每个协程都需要一个这么大的栈。因此，我们引入了<code>share_stack</code>的概念，即多个协程共享一个栈。在<code>coroutine.h</code>中，你需要实现<code>share_stack</code>的相关代码。</p>
<blockquote>
<p>为了不修改<code>coroutine</code>结构体，其内部就是一个<code>stack_mem</code>的数组。</p>
<p>注意：当<code>count</code>不为1时，你需要维护一种<code>stack_mem</code>的使用方式，以减少拷贝带来的开销。</p>
</blockquote>
<p>所谓共享栈，就是所有协程在运行时，使用一个较大的栈，当协程暂停时，只将其使用到的栈空间进行保存（也就是申请一片刚刚好的空间，然后<code>memcpy</code>），当协程恢复时，再将其使用到的栈空间进行恢复（也就是将之前<code>memcpy</code>的内容再copy回来）。</p>
<p>我们使用<code>coroutine_attr</code>结构体在创建时指定协程的属性，其中<code>stack_size</code>表示需要为协程分配的栈大小，<code>sstack</code>表示是否使用共享栈。如果使用共享栈，那么<code>stack_size</code>指向一个<code>share_stack</code>结构体，否则为<code>nullptr</code>。</p>
<blockquote>
<p>这里可能会出现<code>stack_size</code>与<code>sstack</code>所指的<code>share_stack</code>不一致的情况，这种情况下，你需要将协程的<code>stack_size</code>设置为<code>sstack</code>的大小。</p>
</blockquote>
<p>为了实现上面的操作，你需要修改<code>create</code>函数。你可能也需要在其中检测<code>attr</code>传入的数据是否合理，例如栈大小应该在<code>8k</code>到<code>128k</code>之间，否则强制修改到边界值。另外，最好让<code>stack_size</code>为<code>4k</code>的倍数，可以通过位操作来检验和修改。</p>
<p>然后，你需要修改<code>swap</code>函数，使其支持共享栈的切换。在这里，你可能也需要向全局的<code>coroutine_env</code>中添加一些成员变量，用于记录协程的切换信息（因为中间会发生上下文切换！）。对于栈的保存，我们给出了辅助函数<code>save_stack</code>的框架。</p>
<blockquote>
<p>需要指出的是，在共享栈有多于一个栈时，我们为了减小开销，也会使用<code>lazy</code>的方式，只有当改栈有新的协程使用时，才进行保存操作，因此，你可能需要修改<code>stack_mem</code>使其记住上一个使用者，当其被驱逐时，需要保存栈到对应的协程中（此处也需要向<code>coroutine</code>添加成员变量）。</p>
<p>此外，你需要判断如果新来的和上一个使用者是同一个协程，那么就不需要保存。</p>
<p>另外，需要补充的是，共享栈和私有栈是会同时存在的，至少<code>main_coro</code>是私有栈。作为库的编写者，我们也需要给用户更多选择的权力。</p>
<p>比较技术（<del>魔法</del>）的一点是，你需要在<code>swap</code>函数中知道当前协程使用了多少的栈空间。对此我们不直接给出，一个提示是考虑任务一中你观察到的结果。</p>
<p>以上操作都发生在<code>swap</code>函数中，如无必要，其它函数不需要修改。</p>
</blockquote>
<p>在完成了上述的代码后，你可以进入到<code>libco/libco_v2</code>文件夹下，使用<code>make</code>命令编译代码，并使用<code>./main</code>命令运行代码了。</p>
<p>到这里，关于有栈协程的实现就告一段落了。你是否已经对其有了一定的了解了呢？</p>
<p>需要补充的是，我们这里实现的是一个极为简略的协程库，实际上，协程库还需要考虑很多问题，例如协程的调度等等。但这些问题并不是我们本次实验的重点，因此我们不会在这里进行讨论。如果你对此感兴趣，可以自行查阅资料。</p>
<h3 id="part-3-10分">part 3 （10分）</h3>
<p>本部分对应<code>libco/libco_v3</code>。</p>
<p>通过上面的讨论，你可能存在一些疑惑，例如，使用独享栈太浪费了，使用共享栈又会带来额外的开销，那么有没有一种更好的方式呢？为什么协程函数只能返回给调用者，而不能返回给其他协程呢？</p>
<p>在这里，我们将引入无栈协程的概念。</p>
<p>再次回到之前谈论的内容，我们说CPU本质上是一个状态机，那么我们可不可以把我们的程序看作是一个更复杂的状态机呢？</p>
<p>当然可以，我们完全可以把函数的每一条语句当作是一条指令，函数的局部变量看作是函数的状态。</p>
<blockquote>
<p>关于这一点的讨论，可以看<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ks4y1Y7Rw/?share_source=copy_web&amp;vd_source=c70231ab6205b1d45c76dbc9398c993f">应用视角的操作系统 (程序的状态机模型；编译优化) [南京大学2023操作系统-P2] (蒋炎岩)</a></p>
</blockquote>
<p>因此，我们通过如下例子来逐步将一个函数改写，使之可以在运行时暂停并恢复。</p>
<p>考虑以下需求，函数每打印一次，就挂起。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;: Hello, ICS 2023!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// susspend</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而挂起本质上就是返回，因此我们可以将其改写为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;: Hello, ICS 2023!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这可以解决函数无法返回的问题，但是，每次返回后并不是从挂起点恢复，而是重新运行函数，这显然不是我们想要的结果。</p>
<p>为此，我们想到了“黑魔法”——<code>goto</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">goto</span> resume;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    label:</span><br><span class="line">    std::cout &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;: Hello, ICS 2023!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">resume:</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这依然存在问题：</p>
<ol type="1">
<li><p>上述代码即使是第一次执行，也会直接“恢复”</p></li>
<li><p>计数器<code>cnt</code>每次都会被初始化为0，而不能保持状态</p></li>
</ol>
<p>对此的解决办法可以使用一个变量记录当前是否是resume，并且将所有变量改写为<code>static</code>。</p>
<p>但这样也存在问题，由于变量是<code>static</code>的，因此，我们无法创建多个协程，因为它们共享了同一份变量。</p>
<p>因此，我们考虑将函数改写为一个类，在类的内部记录函数的运行状态，并重载其<code>operator()</code>使其可以像函数一样被调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo_frame</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> started = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">            started = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">goto</span> resume;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;: Hello, ICS 2023!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    resume:</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们已经实现的函数的暂停和恢复。但如果有多个暂停点，又该如何处理呢？</p>
<p>我们的解决办法是使用<code>switch</code> + <code>goto</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo_frame</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> started = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (started) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">goto</span> resume_1;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">goto</span> resume_2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           std::cout &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;: Hello, ICS 2023!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">           started = <span class="number">1</span>; <span class="keyword">return</span>; resume_1:</span><br><span class="line"></span><br><span class="line">           std::cout &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;: Hello, ICS 2023!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">           started = <span class="number">2</span>; <span class="keyword">return</span>; resume_2:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，每次挂起都存在重复的代码，我们希望可以尽量少的重复我们的代码，你可能会考虑到宏，但当任然存在几个问题：</p>
<ul>
<li><p><code>switch</code>需要知道函数体内有几个暂停点，宏无法做到这一点。除非使用宏参数，但这样每次增加或减少一个挂起点，都需要进行相应的修改。</p></li>
<li><p>暂停点记录当前位置的方式是记录下当前是第几个暂停点，同样不是宏定义能做到的。如果使用宏参数，则依然有修改复杂的问题。</p></li>
</ul>
<p>为此我们可以对当前代码做出一些修改</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">foo_frame</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> started = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(started) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                std::cout &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;: Hello, ICS 2023!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                started = __LINE__; <span class="keyword">return</span>; <span class="keyword">case</span> __LINE__:;</span><br><span class="line"></span><br><span class="line">                std::cout &lt;&lt; cnt++ &lt;&lt; <span class="string">&quot;: Hello, ICS 2023!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">                started = __LINE__; <span class="keyword">return</span>; <span class="keyword">case</span> __LINE__:;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以通过<code>__LINE__</code>来记录当前的位置了。但是，当前仍然存在代码重复问题，并且也还没有实现<code>yield</code>的功能。不过，大致的思想已经展示出来了。</p>
<p>现在，你可以在<code>libco_v3/main.cpp</code>中，实现<code>CO_BEGIN</code>、<code>CO_END</code>、<code>CO_YIELD</code>、<code>CO_RETURN</code>这几个宏，<code>coroutine_base</code>、<code>fib</code>这两个类，使得能够通过<code>main</code>函数中的测试。</p>
<h3 id="part-4-10分">part 4 （10分）</h3>
<p>本部分对应<code>libco/libco_v4</code>。</p>
<p>在part 3中，你可能会想到，如果每个协程都需要手动写一个类，那么会很麻烦。并且，这么无聊的一件事，怎么不交给机器来做呢？</p>
<p>是的，在C++ 20中，我们可以让编译器来帮助我们做这件事。</p>
<p>在本部分实验中，我们需要你熟悉C++ 20中协程的使用方法，并自己动手实现一个<code>generator</code>。</p>
<p><strong>任务四（10分）</strong> 阅读<a target="_blank" rel="noopener" href="https://lewissbaker.github.io/2017/09/25/coroutine-theory">连接</a>中的这几篇文章，结合网上的资料，回答以下问题：</p>
<ol type="1">
<li>协程函数的返回值<code>Coroutine Functor</code>需要有哪些成员？</li>
<li><code>Promise</code>对象需要提供哪些函数？</li>
<li><code>Awaitable object</code>需要提供哪些接口？</li>
<li><code>Coroutine handle</code>通常需要提供哪些函数？</li>
<li>为什么说<code>co_yield</code>和<code>co_return</code>是<code>co_await</code>的语法糖？</li>
<li>简述协程函数的调用过程并阐述上述每个接口函数的功能。（5分）</li>
</ol>
<p>看完上面给出的参考资料后，你需要在<code>libco_v4/generator.h</code>中实现<code>generator</code>的相关内容。</p>
<blockquote>
<p>hint：你需要补全缺失的类以及标准规定的成员函数。</p>
</blockquote>
<p>另外，直接使用<code>resume</code>函数来访问迭代器过于麻烦，因此，我们需要实现一个<code>generator::iterator</code>类，从而可以基于迭代器的语法糖来访问<code>generator</code>。</p>
<p>具体要求和提示以及在<code>libco_v4/generator.h</code>中的注释中给出。</p>
<p>在完成了上述的代码后，你可以进入到<code>libco/libco_v4</code>文件夹下，使用<code>make</code>命令编译代码，并使用<code>./main</code>命令运行代码了。</p>
<h3 id="part-5-20分">part 5 （20分）</h3>
<p>本部分对应<code>libco/libco_v5</code>。</p>
<p>在本部分中，你需要在part 4的基础上，实现一个可以递归的<code>generator</code>。另外，你还需要实现<code>sleep.h</code>中的内容，使得<code>main</code>函数中的测试可以通过。</p>
<blockquote>
<p>hint：为了实现可递归，你可能需要维护一颗调用树以及修改一部分代码。</p>
<p>关于<code>sleep</code>类并不复杂，只是熟悉一下<code>Awaitable object</code>的定义。</p>
</blockquote>
<p>在完成了上述的代码后，你可以进入到<code>libco/libco_v5</code>文件夹下，使用<code>make</code>命令编译代码，并使用<code>./main</code>命令运行代码了。</p>
<h3 id="final">final</h3>
<p>恭喜你，你已经完成了本次实验的所有内容。</p>
<h2 id="四提交事项">四、提交事项</h2>
<ol type="1">
<li>新建文件夹，以你的学号命名，将实验报告和代码放入其中。最终的文件夹结构如下：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;student-id&gt;</span><br><span class="line">├── report.pdf</span><br><span class="line">└── libco</span><br><span class="line">    ├── libco_v1</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>在上级文件夹使用 <code>tar -cf &lt;student-id&gt;.tar &lt;student-id&gt;</code> 将文件夹压缩成 tar 包。</li>
</ol>
<p>你的实验报告应包含以下内容：</p>
<ol type="1">
<li>姓名和学号</li>
<li>本文档中指出需要在实验报告中回答的问题。</li>
<li>你实现的<code>libco</code>的代码。</li>
<li>通过每个测试的截图。</li>
<li>简要的实现思路。</li>
<li>如果有，请列出引用的内容以及参考的资料</li>
<li>对本实验和课程的意见或建议</li>
<li><del>一只可爱的猫猫</del></li>
</ol>
<h2 id="五参考资料">五、参考资料</h2>
<ol type="1">
<li><code>libco_v1</code>参考自云风实现的<a target="_blank" rel="noopener" href="https://github.com/cloudwu/coroutine/">coroutine</a></li>
<li><code>libco_v2</code>参考自微信开源的<a target="_blank" rel="noopener" href="https://github.com/Tencent/libco">libco</a></li>
<li><code>libco_v5</code>参考自<a target="_blank" rel="noopener" href="http://open-std.org/JTC1/SC22/WG21/docs/papers/2020/p2168r0.pdf">提案</a>，对应的<a target="_blank" rel="noopener" href="https://godbolt.org/">代码</a></li>
</ol>

  </div>
</article>



    </div>
    
      <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/ics/">Home</a></li>
         
          <li><a href="/ics/staff/">Staff</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/cjinfdu/ics">Github</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%AE%9E%E9%AA%8C%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">一、实验简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-number">2.</span> <span class="toc-text">二、实验内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#part-0"><span class="toc-number">2.1.</span> <span class="toc-text">part 0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-1-10%E5%88%86"><span class="toc-number">2.2.</span> <span class="toc-text">part 1 （10分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-2-18%E5%88%86"><span class="toc-number">2.3.</span> <span class="toc-text">part 2 （18分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-2.5-10%E5%88%86"><span class="toc-number">2.4.</span> <span class="toc-text">part 2.5 （10分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-3-10%E5%88%86"><span class="toc-number">2.5.</span> <span class="toc-text">part 3 （10分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-4-10%E5%88%86"><span class="toc-number">2.6.</span> <span class="toc-text">part 4 （10分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#part-5-20%E5%88%86"><span class="toc-number">2.7.</span> <span class="toc-text">part 5 （20分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">2.8.</span> <span class="toc-text">final</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%8F%90%E4%BA%A4%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.</span> <span class="toc-text">四、提交事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.</span> <span class="toc-text">五、参考资料</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://cjinfdu.github.io/ics/CoroutineLab/"><i class="fa fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://cjinfdu.github.io/ics/CoroutineLab/&text=Coroutine lab"><i class="fa fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://cjinfdu.github.io/ics/CoroutineLab/&title=Coroutine lab"><i class="fa fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://cjinfdu.github.io/ics/CoroutineLab/&is_video=false&description=Coroutine lab"><i class="fa fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Coroutine lab&body=Check out this article: https://cjinfdu.github.io/ics/CoroutineLab/"><i class="fa fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://cjinfdu.github.io/ics/CoroutineLab/&title=Coroutine lab"><i class="fa fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://cjinfdu.github.io/ics/CoroutineLab/&title=Coroutine lab"><i class="fa fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://cjinfdu.github.io/ics/CoroutineLab/&title=Coroutine lab"><i class="fa fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://cjinfdu.github.io/ics/CoroutineLab/&title=Coroutine lab"><i class="fa fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://cjinfdu.github.io/ics/CoroutineLab/&name=Coroutine lab&description="><i class="fa fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
      <ul>
        <li id="toc"><a class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa fa-list fa-lg" aria-hidden="true"></i> TOC</a></li>
        <li id="share"><a class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa fa-share-alt fa-lg" aria-hidden="true"></i> Share</a></li>
        <li id="top" style="display:none"><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></li>
        <li id="menu"><a class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa fa-bars fa-lg" aria-hidden="true"></i> Menu</a></li>
      </ul>
    </div>

  </div>
</div>

    
    <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2023 FDUICS-2023助教组
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/ics/">Home</a></li>
         
          <li><a href="/ics/staff/">Staff</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/cjinfdu/ics">Github</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

</body>
</html>
<!-- styles -->

<link rel="stylesheet" href="/ics/lib/font-awesome/css/font-awesome.min.css">


<link rel="stylesheet" href="/ics/lib/meslo-LG/styles.css">


<link rel="stylesheet" href="/ics/lib/justified-gallery/justifiedGallery.min.css">


<!-- jquery -->

<script src="/ics/lib/jquery/jquery.min.js"></script>


<script src="/ics/lib/justified-gallery/jquery.justifiedGallery.min.js"></script>


<script src="/ics/js/main.js"></script>





